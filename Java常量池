引入：方法区常量池概述      
     方法区包含运行时常量池、自动和方法数据、构造函数和普通方法的字节码内容、一些特殊方法。这里虽然没有具体说字符串常量池，但是它也是方法区的一部分。
    在JDK1.8中，使用元空间代替永久代来实现方法区，但是方法区并没有改变，变动的只是方法区中内容的物理存放位置。正如上面所说，类型信息（元数据信息）等其他信息被移动到了元空间中；
    但是运行时常量池和字符串常量池被移动到了堆中。但是不论它们物理上如何存放，Java常量池逻辑上还是属于方法区的。
在Java的内存分配中，总共3种常量池：
1.字符串常量池
      全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（string pool中存的是引用值而不是具体的实例对象，
      具体的实例对象是在堆中开辟的一块空间存放的）。
    在HotSpot VM里实现的string  pool功能的是一个StringTable类，它是一个Hash表，默认值大小长度是1009；这个StringTable在每个HotSpot  VM的实例只有一份，被所有的类共享。字符串常量由一个一个字符组成，放在了StringTable上。
● 在JDK6.0及之前版本中，String Pool里放的都是字符串常量；
● 在JDK7.0中，由于String#intern()发生了改变，因此String Pool中也可以存放放于堆内的字符串对象的引用。
这里字符串常量池里的字符串实际上是驻留字符串。
驻留的英文是Interning，这和代码上new String("abs").intern()的intern方法是一个意思，就是拿到“abs”字符串在字符串常量池里的引用，这个指定abs字符串在字符串常量池的唯一引用就是驻留。
通过intern()方法，实际上"abs"==new String("abs").intern()这个布尔结果就是true，而"abs"==new String("abs")的结果是false。
在 JAVA 语言中有8中基本类型和一种比较特殊的类型String。这些类型为了使他们在运行过程中速度更快，更节省内存，都提供了一种常量池的概念。常量池就类似一个JAVA系统级别提供的缓存。
8种基本类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种：
● 直接使用双引号声明出来的String对象会直接存储在常量池中。
● 如果不是用双引号声明的String对象，可以使用String提供的intern方法。当调用 intern方法时，如果池已经包含一个等于此String对象的字符串（用equals(object)方法确定），则返回池中的字符串。
否则，将此String对象添加到池中，并返回此String对象的引用()。 
2.Class常量池(Class Constant Pool)：
     我们写的每一个Java类被编译后，就会形成一份class文件；class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant  pool table)，
     用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)； 每个class文件都有一个class常量池。
● 字面量包括：1.文本字符串 2.八种基本类型的值 3.被声明为final的常量等;
● 符号引用包括：1.类和方法的全限定名 2.字段的名称和描述符 3.方法的名称和描述符。
3.运行时常量池（runtime constant pool）
      当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。 
● 运行时常量池存在于内存中，也就是class常量池被加载到内存之后的版本，不同之处是：它的字面量可以动态的添加(String#intern()),符号引用可以被解析为直接引用
● JVM在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，
由此可知，运行时常量池也是每个类都有一个。在解析阶段，会把符号引用替换为直接引用，解析的过程会去查询字符串常量池，也就是我们上面所说的StringTable，
以保证运行时常量池所引用的字符串与字符串常量池中是一致的。
