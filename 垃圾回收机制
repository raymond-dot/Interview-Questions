1. 什么是垃圾
在 Java 世界中，几乎所有的对象实例都在堆中存放，所以垃圾回收也主要是针对堆来进行的。
简单一句就是：如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾。

2.垃圾判断算法
1. 引用计数法
    在这种算法中， 假设堆中每个对象（不是引用）都有一个引用计数器。当一个对象被创建并且初始化赋值后，该对象的计数器的值就设置为 1，每当有一个地方引用它时，计数器的值就加 1。
如果这个对象的引用次数为0，代表这个对象可回收。
优点：
● 实时性较高，无需等到内存不够的时候，才开始回收，运行时根据对象的计数器是否为0，就可以直接回收。
● 在垃圾回收过程中，应用无需挂起。如果申请内存时，内存不足，则立刻报OOM错误。
● 区域性，更新对象的计数器时，只是影响到该对象，不会扫描全部对象。
缺点：
● 每次对象被引用时，都需要去更新计数器，有一点时间开销。
● 浪费CPU资源，即使内存够用，仍然在运行时进行计数器的统计。
● 无法解决循环引用问题，会引发内存泄露。（最大的缺点）

2.可达性分析法（现在的虚拟机采用的都是通过可达性分析算法来确定哪些内容是垃圾。）
      可达性分析法也被称之为根搜索法，可达性是指，如果一个对象会被至少一个在程序中的变量通过直接或间接的方式被其他可达的对象引用，则称该对象就是可达的。更准确的说，一个对象只有满足下述两个条件之一，就会被判断为可达的：
● 对象是属于根集中的对象
● 对象被一个可达的对象引用
      在这里，我们引出了一个专有名词，即根集，其是指正在执行的 Java 程序可以访问的引用变量（注意，不是对象）的集合，程序可以使用引用变量访问对象的属性和调用对象的方法。在 JVM 中，会将以下对象标记为根集中的对象，具体包括：
● 虚拟机栈（栈帧中的本地变量表）中引用的对象
● 方法区中的常量引用的对象
● 方法区中的类静态属性引用的对象
● 本地方法栈中 JNI（Native 方法）的引用对象
● 活跃线程（已启动且未停止的 Java 线程）
   根集中的对象称之为GC Roots，也就是根对象。可达性分析法的基本思路是：将一系列的根对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，如果一个对象到根对象没有任何引用链相连，那么这个对象就不是可达的，也称之为不可达对象。

如上图所示，形象的展示了可达对象与不可达对象的示例，其中灰色的对象都是不可达对象，表示可以被垃圾收集的对象。在可达性分析法中，对象有两种状态，那么是可达的、要么是不可达的，在判断一个对象的可达性的时候，就需要对对象进行标记。关于标记阶段，有几个关键点是值得我们注意的，分别是：
● 开始进行标记前，需要先暂停应用线程，否则如果对象图一直在变化的话是无法真正去遍历它的。暂停应用线程以便 JVM 可以尽情地收拾家务的这种情况又被称之为安全点（Safe Point），这会触发一次 Stop The World（STW）暂停。触发安全点的原因有许多，但最常见的应该就是垃圾回收了。
  ○ 安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的。“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生安全点。对于安全点，另一个需要考虑的问题就是如何在  GC 发生时让所有线程（这里不包括执行 JNI 调用的线程）都“跑”到最近的安全点上再停顿下来。两种解决方案：
    ■ 抢先式中断（Preemptive Suspension）：抢先式中断不需要线程的执行代码主动去配合，在 GC 发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机采用这种方式来暂停线程从而响应 GC 事件。
    ■ 主动式中断（Voluntary Suspension）：主动式中断的思想是当 GC 需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志地地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。

● 暂停时间的长短并不取决于堆内对象的多少也不是堆的大小，而是存活对象的多少。因此，调高堆的大小并不会影响到标记阶段的时间长短。

● 在根搜索算法中，要真正宣告一个对象死亡，至少要经历两次标记过程：（重要）
  ○ 如果对象在进行根搜索后发现没有与根对象相连接的引用链，那它会被第一次标记并且进行一次筛选。筛选的条件是此对象是否有必要执行 finalize()方法。当对象没有覆盖finalize()方法，或finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。
  ○ 如果该对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在一个名为F-Queue的队列中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行finalize()方法。finalize()方法是对象逃脱死亡命运的最后一次机会（因为一个对象的finalize()方法最多只会被系统自动调用一次），稍后 GC 将对F-Queue中的对象进行第二次小规模的标记，如果要在finalize()方法中成功拯救自己，只要在finalize()方法中让该对象重新引用链上的任何一个对象建立关联即可。而如果对象这时还没有关联到任何链上的引用，那它就会被回收掉。
● 
      上图是对象被回收的过程。一个对象要被回收，至少要经过两次标记。如果对象在第二次标记之前重新连接上GC Roots，那么它将在第二次标记中被移出回收队列，从而复活。

     对象中存在一个方法【finalize】。当对象被标记为可回收后，当发生GC时，首先会判断这个对象是否执行了finalize方法，如果这个方法还没有被执行的话，那么就会先来执行这个方法，接着在这个方法执行中，可以设置当前这个对象与GC ROOTS产生关联，那么这个方法执行完成之后，GC会再次判断对象是否可达，如果仍然不可达，则会进行回收，如果可达了，则不会进行回收。
     finalize方法对于每一个对象来说，只会执行一次。如果第一次执行这个方法的时候，设置了当前对象与GC ROOTS关联，那么这一次不会进行回收。 那么等到这个对象第二次被标记为可回收时，那么该对象的finalize方法就不会再次执行了。

● GC 判断对象是否可达看的是强引用。
上面的介绍中，我们多次提到了“引用”这个概念，在此我们不妨多了解一些引用的知识，在 Java 中有四种引用类型，分别为：
● 强引用（Strong Reference）：如Object obj = new Object()，这类引用是 Java 程序中最普遍的。只要强引用还在，对象就不会被回收。
● 软引用（Soft Reference）：它用来描述一些可能还有用，但并非必须的对象。被软引用关联的对象在内存不足时会被回收。这个特性特别适合用来做缓存。
● 弱引用（Weak Reference）：它也是用来描述非必须对象的，但它的强度比软引用更弱些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。被弱引用关联的对象每次GC时都会被回收。弱引用最常见的用途是实现可自动清理的集合或者队列。
● 虚引用（Phantom Reference）：也称为幻引用，最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。它完全不会影响对象的生存时间，唯一的作用是在对象被回收时发一个系统通知。

当标记阶段完成后，GC 开始进入下一阶段，删除不可达对象。当然，可达性分析法有优点也有缺点，
● 优点：可以解决循环引用的问题，不需要占用额外的空间
● 缺点：多线程场景下，其他线程可能会更新已经访问过的对象的引用

3.垃圾回收算法
1.标记-清除算法
标记清除算法，是将垃圾回收分为2个阶段，分别是标记和清除。
1.根据可达性分析算法得出的垃圾进行标记
2.对这些标记为可回收的内容进行垃圾回收

可以看到，标记清除算法解决了引用计数算法中的循环引用的问题，没有从root节点引用的对象都会被回收。
它的主要缺点有两个：
● 效率不高，标记和清除两个动作都需要遍历所有的对象，并且在GC时，需要停止应用程序，对于交互性要求比较高的应用而言这个体验是非常差的。
● 会产生大量内存碎片(重要)

2.复制算法
复制算法的核心就是，将原有的内存空间一分为二，每次只用其中的一块，在垃圾回收时，将正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收。周而复始。
如果内存中的垃圾对象较多，需要复制的对象就较少，这种情况下适合使用该方式并且效率比较高，反之，则不适合。

1）将内存区域分成两部分，每次操作其中一个。
2）当进行垃圾回收时，将正在使用的内存区域中的存活对象移动到未使用的内存区域。当移动完对这部分内存区
域一次性清除。
3）周而复始。
优点：在垃圾对象多的情况下，效率较高，清理后，内存无碎片
缺点：分配的2块内存空间，在同一个时刻，只能使用一半，内存使用率较低

3.标记-整理算法
标记压缩算法是在标记清除算法的基础之上，做了优化改进的算法。和标记清除算法一样，也是从根节点开始，对对象的引用进行标记，在清理阶段，并不是简单的直接清理可回收对象，而是将存活对象都向内存另一端移动，然后清理边界以外的垃圾，从而解决了碎片化的问题。

1）标记垃圾。
2）需要清除向右边走，不需要清除的向左边走。
3）清除边界以外的垃圾。
优缺点同标记清除算法，解决了标记清除算法的碎片化的问题，同时，标记压缩算法多了一步，对象移动内存位置的步骤，其效率也有有一定的影响。

4.分代收集算法
分代收集算法其实没什么新东西，只是把对象按存活率分块，然后选用合适的收集算法。java中使用的就是分代收集算法。
存活率低的对象放在一起，称为新生代，使用复制算法来收集。
存活率高的对象放在一起，称为老年代，使用标记-清除或者标记-整理算法。

在java8时，堆被分为了两份：新生代和老年代【1：2】，在java7时，还存在一个永久代。

对于新生代，内部又被分为了三个区域。Eden区，S0区，S1区【8：1：1】
当对新生代产生GC：MinorGC【young GC】
当对老年代产生GC：FullGC【OldGC】
1）工作机制
1）当创建一个对象的时候，那么这个对象会被分配在新生代的Eden区。当Eden区要满了时候，触发YoungGC。
2）当进行YoungGC后，此时在Eden区存活的对象被移动到S0区，并且当前对象的年龄会加1，清空Eden区。
3）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和S0中的对象，移动到S1区中，这些对象的年
龄会加1，清空Eden区和S0区。
4）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和S1中的对象，移动到S0区中，这些对象的年
龄会加1，清空Eden区和S1区。
2）对象何时晋升到老年代
1）对象的年龄达到了某一个限定的值（默认15岁，CMS默认6岁 ），那么这个对象就会进入到老年代中。
2）大对象。
3）如果在Survivor区中相同年龄的对象的所有大小之和超过Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。
当老年代满了之后，触发FullGC。FullGC同时回收新生代和老年代，当前只会存在一个FullGC的线程进行执行，其他的线程全部会被挂起。

4.垃圾收集器
在jvm中，实现了多种垃圾收集器，包括：串行垃圾收集器、并行垃圾收集器、CMS（并发）垃圾收集器、G1垃圾收集器。
在开始讲解之前，我们先了解一下什么是并行和并发。
并行：垃圾收集器是多线程同时工作的，但是用户线程仍然处于等待状态。
并发：用户线程和垃圾收集器线程同时执行（也有可能是交替执行）。

1.串行垃圾收集器（Serial收集器）

    串行垃圾收集器，是指使用单线程进行垃圾回收，垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要暂停，等待垃圾回收的完成。这种现象称之为STW（Stop-The-World）。其应用在年轻代
对于交互性较强的应用而言，这种垃圾收集器是不能够接受的。因此一般在Javaweb应用中是不会采用该收集器的。  串行垃圾收集器使用复制算法。


2.并行垃圾收集器Parallel
并行垃圾收集器在串行垃圾收集器的基础之上做了改进，将单线程改为了多线程进行垃圾回收，这样可以缩短垃圾回收的时间。（这里是指，并行能力较强的机器）。同样也是应用在年轻代。
当然了，并行垃圾收集器在收集的过程中也会暂停应用程序，这个和串行垃圾回收器是一样的，只是并行执行，速度更快些，暂停的时间更短一些。

1）ParNew垃圾收集器
   ParNew收集器其实是Serial收集器的多线程版本，与Serial不同的地方就是在垃圾收集过程中使用多个线程，剩下的所有行为包括控制参数、收集算法、Stop the World、对象分配规则和回收策略等都一样。ParNew收集器也使用复制算法。
  ParNew收集器看似没有多大的创新之处，但却是许多运行在Server模式下的虚拟机中首选的新生代收集器，因为，除了Serial收集器外，目前只有ParNew收集器能够与CMS收集器配合工作，而CMS收集器是HotSpot在JDK  1.5时期推出的具有划时代意义的垃圾收集器（后面会介绍到）。
2）ParallelGC垃圾收集器（jdk8默认垃圾收集器）
3.CMS（并发）垃圾收集器
CMS全称 Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的垃圾回收器，该回收器是针对老年代垃圾回收的，gc的时间能够在200ms内完成。通过参数-XX:+UseConcMarkSweepGC进行设置。
其最核心的特点是在进行垃圾回收时，应用仍然能正常运行。

4.G1垃圾收集器（在JDK9之后默认使用G1，重点）

G1收集器使用的也是分代算法，它的思路是，把内存空间分成一个个小格子，每个格子称为一个Region。优先回收价值大的Region。
G1垃圾收集器相对比其他收集器而言，最大的区别在于它取消了年轻代、老年代的物理划分。
取而代之的是将堆划分为若干个区域（Region），这些区域中包含了有逻辑上的年轻代、老年代区域。这样做的好处就是，我们再也不用单独的空间对每个代进行设置了，不用担心每个代内存是否足够。
此时可以看到，现在出现了一个新的区域Humongous，它本身属于老年代区。当现在出现了一个巨大的对象，超出了分区容量的一半，则这个对象会进入到该区域。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区 ，有时候不得不启动Full GC。

年轻代使用并发复制算法，有STW。
老年代回收步骤大致可以分为以下几个：
● 初始标记（STW）
● 并发标记
● 最终标记（STW）
● 筛选回收（STW）
常见的垃圾收集器？
1. 新生代收集器使用的收集器：Serial、PraNew、Parallel Scavenge
2. 老年代收集器使用的收集器：Serial Old、Parallel Old、CMS
简述分代垃圾回收器是怎么工作的？
1. 老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3
2. Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1
3. 把 Eden + From Survivor 存活的对象放入 To Survivor 区；
4. 清空 Eden 和 From Survivor 分区； From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。
5. 每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。
6. 老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。

5、垃圾回收模式
其提供了三种模式垃圾回收模式： young GC、Mixed GC、Full GC。在不同的条件下被触发。
1.Young GC
发生在年轻代的GC算法，一般对象（除了巨型对象）都是在eden region中分配内存，当所有eden region被耗尽
无法申请内存时，就会触发一次young gc，这种触发机制和之前的young gc差不多，执行完一次young gc，活跃
对象会被拷贝到survivor region或者晋升到old region中，空闲的region会被放入空闲列表中，等待下次被使用。

2、Mixed GC
      当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即
mixed gc，该算法并不是一个old gc，除了回收整个young region，还会回收一部分的old region，这里需要注
意：是一部分老年代，而不是全部老年代，可以选择哪些old region进行收集，从而可以对垃圾回收的耗时时间进
行控制。
在CMS中，当老年代的使用率达到80%就会触发一次cms gc。在G1中，mixed gc也可以通过-XX:InitiatingHeapOccupancyPercent 设置阈值，默认为45%。当老年代大小占整个堆大小百分比达到该阈值，则
触发mixed gc。
其执行过程和cms类似：
1. initial mark: 初始标记过程，整个过程STW，标记了从GC Root可达的对象。
2. concurrent marking: 并发标记过程，整个过程gc collector线程与应用线程可以并行执行，标记出GC Root可
达对象衍生出去的存活对象，并收集各个Region的存活对象信息。
3. remark: 最终标记过程，整个过程STW，标记出那些在并发标记过程中遗漏的，或者内部引用发生变化的对
象。
4. clean up: 垃圾清除过程，如果发现一个Region中没有存活对象，则把该Region加入到空闲列表中。

3、Full GC
    如果对象内存分配速度过快，mixed gc来不及回收，导致老年代被填满，就会触发一次full gc，G1的full gc算法就是单线程执行的serial old gc，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免full gc.
