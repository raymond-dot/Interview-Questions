JAVA五种IO模型
同步与异步：
同步与异步是针对应用程序与内核的交互而言。（内核，是一个操作系统的核心。是基于硬件的第一层软件扩充，提供操作系统的最基本的功能，是操作系统工作的基础，它负责管理系统的进程、内存、内核体系结构、设备驱动程序、文件和网络系统，决定着系统的性能和稳定性。）
同步过程中进程触发IO操作并等待或者轮询的去查看IO操作是否完成。
异步过程中进程触发IO操作以后，直接返回，做自己的事情，IO操作交给内核来处理， 处理完后通知进程IO完成
同步和异步是相对于操作结果来说，会不会等待结果返回；
阻塞与非阻塞：
应用进程请求IO操作时，如果数据未准备好，立即返回就是非阻塞，不立即返回就是阻塞。简单来说，就是做一件事如果不能立即获得返回，需要等待，就是阻塞，否则就是非阻塞。
阻塞与非阻塞是相对于线程是否被阻塞。
异步/同步/ 阻塞/非阻塞 的区别
两者存在本质的区别，他们的修饰对象是不同的。
阻塞和非阻塞是指进程访问的数据如果尚未准备就绪，进程是否需要等待，简单说：相等于函数内部的实现区别，就是未就绪时，直接返回还是等待就绪 。
同步和异步是指访问数据的机制，同步一般主动请求等待IO操作完毕的方式。当数据就绪后，再读写的时候必须阻塞，异步则主动请求数据后便可以继续处理其他任务，随后等待IO完毕通知，这可以使进程在数据读写时也不阻塞
异步/同步 阻塞/非阻塞的组合方式
同步阻塞：效率最低，实际程序中，就是fd未设置O_NONBLOCK标志位的read/write操作。
老王用水壶烧水，并且站在那里，看着水壶，等水开。
异步阻塞：异步操作是可以阻塞住的，只不过它不是在处理消息是阻塞，而是在等到消息时阻塞，
老王用响水壶烧水，站在那里，这次不看水壶了，而是等水开了水壶自动通知发出声音，老王听见了，知道水开了
同步非阻塞：实际效率 还是低下的，注意fd设置O_NONBLOCK标志位
老王用水壶烧水，不在站在那里直接等，而是跑出去去干别的事情，比如打游戏，看电视，但是，老王心里不放心，每隔一段时间回来看一下，看水开了没（异步内核通知进程）
异步非阻塞：效率高效，注册一个回调函数，就可以去做别的事情，
老王用响水壶烧水，跑去做别的事情，等待响水壶发出声音。（异步内核通知进程）

缓存IO
缓存IO又被称为标准IO，大多数文件系统的默认IO都是缓存IO，在linux的缓存IO机制中，造作系统会将IO的数据缓存在文件系统的页缓存（page  cache），也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲拷贝到应用程序的地址空间
缓存IO的缺点：
数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝带来的cpu以及内存开销是非常大的。


在《Unix网络编程》一书中提到了五种IO模型，分别是：阻塞IO、非阻塞IO、多路复用IO、信号驱动IO以及异步IO。前4种为同步IO操作，只有异步IO模型是异步IO操作。
1、阻塞IO模型（BIO）
  进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程。操作成功则进程获取到数据。
1、典型应用：阻塞socket、Java BIO；
2、特点：
进程阻塞挂起不消耗CPU资源，及时响应每个操作；
实现难度低、开发应用较容易；
适用并发量小的网络应用开发；

2、非阻塞IO模型
进程发起IO系统调用后，如果内核缓冲区没有数据，需要到IO设备中读取，进程返回一个错误而不会被阻塞；进程发起IO系统调用后，如果内核缓冲区有数据，内核就会把数据返回进程。
1、典型应用：socket是非阻塞的方式（设置为NONBLOCK）
2、特点：
进程轮询（重复）调用，消耗CPU的资源；
实现难度低、开发应用相对阻塞IO模式较难；
 适用并发量较小、且不需要及时响应的网络应用开发；

3、IO复用模型（NIO）
    多个的进程的IO可以注册到一个复用器（select）上，然后用一个进程调用该select， select会监听所有注册进来的IO；
 如果select监听的IO在内核缓冲区都没有可读数据，select调用进程会被阻塞；而当任一IO在内核缓冲区中有可数据时，select调用就会返回；
 而后select调用进程可以自己或通知另外的进程（注册进程）来再次发起读取IO，读取内核中准备好的数据
1、典型应用：select、poll、epoll三种方案，nginx都可以选择使用这三个方案;  Java NIO;
2、特点：
专一进程解决多个进程IO的阻塞问题，性能好；Reactor模式;
实现、开发应用难度较大；
适用高并发服务应用开发：一个进程（线程）响应多个请求；

4、信号驱动IO模型
当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据。
   1、特点：回调机制，实现、开发应用难度大；

5、异步IO模型（AIO）
   当进程发起一个IO操作，进程返回（不阻塞），但也不能返回果结；内核把整个IO处理完后，会通知进程结果。如果IO操作成功则进程直接获取到数据。
1、典型应用：JAVA7 AIO、高性能服务器应用
2、特点：
不阻塞，数据一步到位；Proactor模式；
需要操作系统的底层支持，LINUX 2.5 版本内核首现，2.6 版本产品的内核标准特性；
实现、开发应用难度大；
非常适合高性能高并发应用；

异步IO的拷贝是有内核完成， 其他几种IO都是由用户进程完成；
以上五种IO模型的通俗理解
活动：演唱会
角色一：满满
角色二：举办方-》售票员
角色三：黄牛
角色四：送票快递员
同步阻塞IO：
满满从家到售票点买票，售票员告诉满满，票明天才能卖。满满直接在售票点等到明天买票，然后回家。
非阻塞IO:
满满从家到演唱会现场向售票员买票，但票还未出来，然后满满就走了，去干别的事情，过了几个小时再来询问票是否出来，还没出来继续干别的事情。重复以上操作，直到票可以买。
IO复用： JAVA->selector / linux->select,poll,epoll
满满想买演唱会的票，打电话给黄牛(select)帮留一张票，票出来后，小明是需要花费时间去售票点买票(阻塞)。
信号IO:
满满想买演唱会门票，给举办方打电话，帮我留意票，可以售票了给我打个电话(打完就返回结果，等待kernel信号通知)，我自己来买票。票出来后，满满亲自去售票点买票
异步IO:
满满要看演唱会，给举办方打电话，可以售票了让送票快递员帮我把票送家里，满满就不用自己去专门买票了
