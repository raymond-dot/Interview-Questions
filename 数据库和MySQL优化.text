数据库三大范式是什么
第一范式：每个列都不可以再拆分。(确保每列保持原子性)
第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分（主要针对联合主键而言）。(确保表中的每列都和主键相关)
第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。(确保每列都和主键列直接相关,而不是间接相关)

数据结构:
varchar与char的区别
1）char的长度是不可变的，用空格填充到指定长度大小，而varchar的长度是可变的。
2）char的存取数度还是要比varchar要快得多
3）char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。

小数类型为decimal，禁止使用float和double。
 说明：在存储的时候，float 和 double 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数并分开存储。

什么是数据库事务？
事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。
事务是逻辑上的一组操作，要么都执行，要么都不执行。

事务四大特性(ACID）:
原子性（atomic） ： 事务是最小的执行单位，不允许分割。要么都执行，要么都不执行。
一致性（consistent） ：执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；
隔离性（isolation） ：允许多个用户并发访问,事务之间不会相互干扰。
持久性（durable） ：事务一旦提交，对数据库改变是永久的。

事务的隔离级别:
事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。
脏读:  一个事务读取到了另一个事务中尚未提交的数据
不可重复读:  一个事务中两次读取的数据内容不一致，这是事务update时引发的问题
幻读:  一个事务中两次读取的数据的数量不一致，b这是insert或delete时引发的问题

Mysql 默认采用的 REPEATABLE_READ隔离级别;    Oracle 默认采用的 READ_COMMITTED隔离级别

数据库优化的维度

从上图中可以看出，我们把数据库优化分为四个纬度：硬件，系统配置，数据库表结构，SQL及索引
硬件： CPU、内存、存储、网络设备等
系统配置： 服务器系统、数据库服务参数等
数据库表结构： 高可用、分库分表（垂直拆分和水平拆分）、读写分离、存储引擎、表设计等
Sql及索引： sql语句、索引使用等
从优化成本进行考虑：硬件>系统配置>数据库表结构>SQL及索引
从优化效果进行考虑：硬件<系统配置<数据库表结构<SQL及索引

数据库使用优化思路
应急调优的思路：
针对突然的业务办理卡顿，无法进行正常的业务处理！需要立马解决的场景！
1. show processlist（查看连接session状态）
2. explain(分析查询计划)，show index from tableName（分析索引）
3. show status like '%lock%'; # 查询锁状态
常规调优的思路：
针对业务周期性的卡顿，例如在每天10-11点业务特别慢，但是还能够使用，过了这段时间就好了。
1. 开启慢查询日志，运行一天
2. 查看slowlog，分析slowlog，分析出查询慢的语句。
3. 按照一定优先级，进行一个一个的排查所有慢语句。
4. 分析top sql，进行explain调试，查看语句执行时间。
5. 调整索引或语句本身。

MyISAM和Innodb区别(重要)
1. InnoDB支持事务，MyISAM不支持；
2. InnoDB支持外键，而MyISAM不支持；
3. InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁
4. Innodb不支持全文索引，而MyISAM支持全文索引，PS：5.7以后的InnoDB支持全文索引了；
5、InnoDB表必须有主键（用户没有指定的话会自己找或生产一个主键），而Myisam可以没有；
6. InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数；
  因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的，因此count统计会计算对于当前事务而言可以统计到的行数，而不是将总行数储存起来方便快速查询。
7.  InnoDB是聚簇索引(聚集索引)，  MyISAM是非聚集索引；  
       InnoDB是聚簇索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。
      MyISAM是非聚簇索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。
 也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。 
问题：主键索引是聚集索引还是非聚集索引？
在Innodb下主键索引是聚集索引，在Myisam下主键索引是非聚集索引

如何选择：
    1. 是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；
    2. 如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。
    3. 系统奔溃后，MyISAM恢复起来更困难，能否接受； 
    4. MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。

什么是索引
索引（Index）是帮助MySQL高效获取数据的数据结构。 可以 加快数据的检索速度，但需要占物理空间。
分类：
1. 普通索引：仅加速查询
2. 唯一索引：加速查询 + 列值唯一（可以有null） 唯一约束
3. 主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个 , 主键约束
4. 组合（联合）索引：多列值组成一个索引，注意：最左匹配原则
5. 全文索引：查找文本中的关键字，而不是直接与索引中的值相比较。目前只有char、varchar，text 列上可以创建全文索引。

索引的存储结构
1. B+Tree索引（多路平衡查找树）:B+树非叶子节点存储键,叶子节点存储值，叶子节点使用双向链表连接。
2. 哈希索引:所谓Hash索引，实际上就是通过一定的Hash算法，将需要索引的键进行Hash运算，然后将得到的Hash值存入一个Hash表中。
问题：Hash索引和B+树索引有什么区别或者说优劣呢?
1. hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。
2. hash索引不支持使用索引进行排序，原理同上。

数据库为什么使用B+树而不是B树？
     在B树中，你可以将键和值存放在内部节点和叶子节点；B树适用于读写相对大的数据块的存储系统，例如磁盘。
● b+树的非叶子节点不保存数据，只保存子树的临界值（最大或者最小），所以同样大小的节点，b+树相对于b树能够有更多的分支，使得这棵树更加矮胖，查询时做的IO操作次数也更少。
● 更适于范围查询：在B树中进行范围查询时，首先找到要查找的下限，然后对B树进行中序遍历，直到找到查找的上限；而B+树的范围查询，只需要对链表进行遍历即可。

mysql哪些字段适合建立索引?
1. 表的主键、外键必须有索引； 
2. 数据量500左右的表应该有索引； 
3. 在where从句，group by从句，order by从句，on从句中的列添加索引
4. 索引应该建在选择性高的字段上； 
5. 索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引； 
6. 复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替：
7. 不适合的字段
  a. 表记录少
  b. 经常插入、删除、修改的表，不要建立太多的索引； 
  c. 删除无用的索引，避免对执行计划造成负面影响；
索引失效的情况？
1. 遵守最左前缀法则；
2. 不在索引列上做任何计算；
3. 使用select * 查询；
4. mysql5.7 在使用不等于(!= 或者<>)的时候无法使用索引会导致全表扫描。但8.0不会。
5. mysql5.7 is not null 也无法使用索引，但是is null是可以使用索引的。但8.0不会。
6. like以%开头('%abc...')mysql索引失效会变成全表扫描的操作
7. 如果条件中有or，即使其中有条件带索引也不会使用
8. 索引数据类型不匹配,(隐式转换的影响)

