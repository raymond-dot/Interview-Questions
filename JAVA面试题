1. JDK 和 JRE 有什么区别？    https://blog.csdn.net/o9109003234/article/details/115843165

    JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。
    JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。

具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，
如果你需要编写 java 程序，需要安装 JDK。
2. == 和 equals 的区别是什么？
 == 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较
 ，所以一般情况下 equals 比较的是值是否相等。  

3、java 中操作字符串都有哪些类？它们之间有什么区别？

操作字符串的类有：String、StringBuffer、StringBuilder。

String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，
而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。

StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，
所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。
4. final 在 java 中有什么作用？
● final 修饰的类叫最终类，该类不能被继承。
● final 修饰的方法不能被重写。
● final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。
5、String str="i"与 String str=new String("i")一样吗？

不一样，因为内存的分配方式不一样。String str="i"的方式，java 虚拟机会将其分配到常量池中；而 String str=new String("i") 则会被分到堆内存中。

6、基本数据类型、引用类型在内存中的存储方式
     基本数据类型：存放在栈内存中。用完就消失。
     引用类型：在栈内存中存放引用堆内存的地址，在堆内存中存储类、对象、数组等。当没用引用指向堆内存中的类、对象、数组时，由 GC回收机制不定期自动清理。

7、java 中 IO 流分为几种？
按功能来分：输入流（input）、输出流（output）。
按类型来分：字节流和字符流。
字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。

8、BIO、NIO、AIO 有什么区别？

    BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。进程阻塞挂起不消耗CPU资源，及时响应每个操作；
    NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。
    多个的进程的IO可以注册到一个复用器（select）上，然后用一个进程调用该select， select会监听所有注册进来的IO；
 如果select监听的IO在内核缓冲区都没有可读数据，select调用进程会被阻塞；而当任一IO在内核缓冲区中有可数据时，select调用就会返回；
 而后select调用进程可以自己或通知另外的进程（注册进程）来再次发起读取IO，读取内核中准备好的数据
    AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。
    当进程发起一个IO操作，进程返回（不阻塞），但也不能返回果结；内核把整个IO处理完后，会通知进程结果。如果IO操作成功则进程直接获取到数据。

9、说一下 HashMap 的实现原理？

HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 

HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。
HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。

当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,
那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。

需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)

ArrayList 的扩容机制
1. ArrayList 默认初始容量为10;   
2. 扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。

10.什么是IoC，为什使用IoC ?
IoC (Inversion of Control)即控制反转，它把传统上由程序代码操控的对象的调用权交给spring容器，通过spring容器来实现对象组件的创建、装配和管理。 
(由spring来负责控制对象的生命周期和对象间的关系 )
IOC的好处就是解耦，对象和对象之间的耦合度变低了，便于测试、便于功能复用。 
DI：依赖注入，在程序运行期间,由外部容器动态地将依赖对象注入到组件中。简单定义就是当一个对象需要另一个对象时，把另一个对象注入到对象中去。 
Spring框架提供了两种不同类型的容器。
  a. BeanFactory容器
  b. ApplicationContext容器

11.说一下spring的AOP?
  a. AOP，也就是面向切面编程；其次还有面向过程和面向对象编程。
  b. Spring AOP实现主要是通过代理类的方式实现，有jdk动态代理和CGLIB代理两种方式。
  c. Java动态代理只能够对接口进行代理，不能对普通的类进行代理（因为所有生成的代理类的父类为Proxy，Java类继承机制不允许多重继承）；CGLIB能够代理普通类；
  d. Spring内部，发现如果目标对象没有实现接口，则默认会采用CGLIB代理； 如果目标对象实现了接口，默认会采用Java动态代理；
  e. AOP用到的动态代理是对方法增强的方式之一。
  f. AOP的典型应用就是事务管理 。

代理
	#静态代理：编译时增强，修改目标对象的class文件
  #AspectJ：它会在编译阶段将Aspect织入Java字节码中， 运行的时候就是经过增强之后的AOP对象。
	#动态代理：运行时增强，生成代理对象
  #jdk动态代理：利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。
  	#被代理的对象必须要实现接口
  	#创建一个实现InvocationHandler的代理类
  	#使用Proxy.newProxyInstance(classLoader, interfaces, handler)产生代理对象
  #cglib动态代理：利用asm（一个短小精悍的字节码操作框架）开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。
  	#必须依赖于CGLib的类库
  	#可对无实现接口的类进行代理
  	#Enhancer类为主要类
Spring如何处理线程并发问题？
在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。

ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。
而ThreadLocal采用了“空间换时间”的方式。

ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。
ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。

82. tcp 为什么要三次握手，两次不行吗？为什么？

为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 
并确认对方已经收到了序列号起始值的必经步骤。
 如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。  

44. 创建线程池有哪几种方式？
Java中已经提供了创建线程池的一个类：Executor，而我们创建时，一般使用它的子类：ThreadPoolExecutor.
public ThreadPoolExecutor(int corePoolSize,  int maximumPoolSize,  
                          long keepAliveTime, TimeUnit unit,  
                            BlockingQueue<Runnable> workQueue,  ThreadFactory threadFactory,  RejectedExecutionHandler handler)
 线程池中的corePoolSize就是线程池中的核心线程数量，这几个核心线程，只是在没有用的时候，也不会被回收，maximumPoolSize就是线程池中可以容纳的最大线程的数量，
 而keepAliveTime，就是线程池中除了核心线程之外的其他的最长可以保留的时间，因为在线程池中，除了核心线程即使在无任务的情况下也不能被清除，其余的都是有存活时间的，
 意思就是非核心线程可以保留的最长的空闲时间，而util，就是计算这个时间的一个单位，workQueue，就是等待队列，任务可以储存在任务队列中等待被执行，执行的是FIFIO原则（先进先出）。
 threadFactory，就是创建线程的线程工厂，最后一个handler,是一种拒绝策略，我们可以在任务满了知乎，拒绝执行某些任务。
 线程池的执行流程又是怎样的呢？
 任务进来时，首先执行判断，判断核心线程是否处于空闲状态，如果不是，核心线程就先就执行任务，如果核心线程已满，则判断任务队列是否有地方存放该任务，
 若果有，就将任务保存在任务队列中，等待执行，如果满了，在判断最大可容纳的线程数，如果没有超出这个数量，就开创非核心线程执行任务，如果超出了，就调用handler实现拒绝策略。

handler的拒绝策略有四种：
             第一种AbortPolicy:不执行新任务，直接抛出异常，提示线程池已满

             第二种DisCardPolicy:不执行新任务，也不抛出异常

             第三种DisCardOldSetPolicy:将消息队列中的第一个任务替换为当前新进来的任务执行

             第四种CallerRunsPolicy:直接调用execute来执行当前任务
	     
四种常见的线程池：

CachedThreadPool:可缓存的线程池，该线程池中没有核心线程，非核心线程的数量为Integer.max_value，就是无限大，当有需要时创建线程来执行任务，没有需要时回收线程，适用于耗时少，任务量大的情况。

SecudleThreadPool:周期性执行任务的线程池，按照某种特定的计划执行线程中的任务，有核心线程，但也有非核心线程，非核心线程的大小也为无限大。适用于执行周期性的任务。

SingleThreadPool:只有一条线程来执行任务，适用于有顺序的任务的应用场景。

FixedThreadPool:定长的线程池，有核心线程，核心线程的即为最大的线程数量，没有非核心线程
    

 
2.redis的持久化方式区别及其选择？（重要）
Redis 提供了 RDB 和 AOF 两种持久化方式：
RDB 是把内存中的数据集以快照形式写入磁盘，实际操作是通过 fork 子进程执行，采用二进制压缩存储；
AOF 是以文本日志的形式记录 Redis 处理的每一个写入或删除操作。
RDB 把整个 Redis 的数据保存在单一文件中，比较适合用来做灾备，但缺点是快照保存完成之前如果宕机，这段时间的数据将会丢失，另外保存快照时可能导致服务短时间不可用。
AOF 对日志文件的写入操作使用的追加模式，有灵活的同步策略，支持每秒同步、每次修改同步和不同步，缺点就是相同规模的数据集，AOF 要大于 RDB，AOF 在运行效率上往往会慢于 RDB。

redis的缓存击穿问题？如何解决？
1. 缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，缓存没读到数据，去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。
2. 关键字：缓存没有数据库有，并发多。
3. 和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。
4. 和缓存穿透不同的是，缓存穿透指缓存和数据库中都没有的数据。缓存击穿指的是缓存没有，数据库有
解决方案：
1. 设置热点数据永远不过期。
2. 加互斥锁(mutex key)。简单来讲，就是要操作db，需要排队。
redis的缓存穿透问题？如何解决？
缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求 
常见3种方案：
1. 增加接口层校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；
2. key-null存入缓存，从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。
这样可以防止攻击用户反复用同一个id暴力攻击
3. 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力
redis的缓存雪崩问题？怎么解决？
在高并发下，大量的缓存在同一时间失效，导致大量的请求落到数据库上
解决方案：
1. 设置不同的失效时间,比如随机设置缓存的失效时间。
2. 一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。
3. 设置热点数据永远不过期。
Redis的过期键的删除策略？
1. Redis中同时使用了惰性过期和定期过期两种过期策略。
2. 常见有3种过期策略，定期过期，定时过期，惰性过期。
3. 惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，
从而不会被清除，占用大量内存。
4. 定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。
5. 定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，
从而影响缓存的响应时间和吞吐量。
6. 定期、定时，是主动删除。惰性，是被动删除。
redis的使用场景？（
1. 缓存，将热点数据放到内存中。
2. 计数器，可以对 String 进行自增自减运算，从而实现计数器功能。
3. 队列，List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。
4. 分布式锁，在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。
5. 会话缓存，可以使用 Redis 来统一存储多台应用服务器的会话信息。
6. 全页缓存（FPC），除基本的会话token之外，Redis还提供很简便的FPC平台。没接触过。
7. 交集、差集、并集，Set 可以实现交集、差集、并集等操作，从而实现共同好友等功能。没接触过。
8. 排行榜，ZSet 可以实现有序性操作，从而实现排行榜等功能。没接触过。
9. 发布/订阅功能，用的少，没有MQ好。没接触过。


Linux 常用命令
2.1 目录切换 cd

2.2 目录查看 ls [-al]

2.3 目录操作【增，删，改，查】

2.3.1 创建目录【增】 mkdir

2.3.2 删除目录或文件【删】rm

2.3.3 目录修改【改】mv 和 cp

2.3.4 搜索目录【查】find

三、文件操作命令

3.1 文件操作【增，删，改，查】

3.1.1 新建文件【增】touch

3.1.2 删除文件 【删】 rm

3.1.3 修改文件【改】 vi或vim

3.1.4 文件的查看【查】  cat/more/less/tail

四、压缩文件操作

4.1 打包和压缩  tar -zcvf 打包压缩后的文件名 要打包的文件
其中：z：调用gzip压缩命令进行压缩
  c：打包文件
  v：显示运行过程
  f：指定文件名

4.2 解压


