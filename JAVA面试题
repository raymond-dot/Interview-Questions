1. JDK 和 JRE 有什么区别？

    JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。
    JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。

具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，
如果你需要编写 java 程序，需要安装 JDK。
2. == 和 equals 的区别是什么？
 == 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较
 ，所以一般情况下 equals 比较的是值是否相等。  

3、java 中操作字符串都有哪些类？它们之间有什么区别？

操作字符串的类有：String、StringBuffer、StringBuilder。

String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，
而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。

StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，
所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。
4. final 在 java 中有什么作用？
● final 修饰的类叫最终类，该类不能被继承。
● final 修饰的方法不能被重写。
● final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。
5、String str="i"与 String str=new String("i")一样吗？

不一样，因为内存的分配方式不一样。String str="i"的方式，java 虚拟机会将其分配到常量池中；而 String str=new String("i") 则会被分到堆内存中。

6、基本数据类型、引用类型在内存中的存储方式
     基本数据类型：存放在栈内存中。用完就消失。
     引用类型：在栈内存中存放引用堆内存的地址，在堆内存中存储类、对象、数组等。当没用引用指向堆内存中的类、对象、数组时，由 GC回收机制不定期自动清理。

7、java 中 IO 流分为几种？
按功能来分：输入流（input）、输出流（output）。
按类型来分：字节流和字符流。
字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。

8、BIO、NIO、AIO 有什么区别？

    BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。进程阻塞挂起不消耗CPU资源，及时响应每个操作；
    NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。
    多个的进程的IO可以注册到一个复用器（select）上，然后用一个进程调用该select， select会监听所有注册进来的IO；
 如果select监听的IO在内核缓冲区都没有可读数据，select调用进程会被阻塞；而当任一IO在内核缓冲区中有可数据时，select调用就会返回；
 而后select调用进程可以自己或通知另外的进程（注册进程）来再次发起读取IO，读取内核中准备好的数据
    AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。
    当进程发起一个IO操作，进程返回（不阻塞），但也不能返回果结；内核把整个IO处理完后，会通知进程结果。如果IO操作成功则进程直接获取到数据。

9、说一下 HashMap 的实现原理？

HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 

HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。
HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。

当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,
那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。

需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)

10.什么是IoC，为什使用IoC ?
IoC (Inversion of Control)即控制反转，它把传统上由程序代码操控的对象的调用权交给spring容器，通过spring容器来实现对象组件的创建、装配和管理。  (由spring来负责控制对象的生命周期和对象间的关系 )
IOC的好处就是解耦，对象和对象之间的耦合度变低了，便于测试、便于功能复用。 
DI：依赖注入，在程序运行期间,由外部容器动态地将依赖对象注入到组件中。简单定义就是当一个对象需要另一个对象时，把另一个对象注入到对象中去。 
Spring框架提供了两种不同类型的容器。
  a. BeanFactory容器
  b. ApplicationContext容器

11.说一下spring的AOP?
  a. AOP，也就是面向切面编程；其次还有面向过程和面向对象编程。
  b. Spring AOP实现主要是通过代理类的方式实现，有jdk动态代理和CGLIB代理两种方式。
  c. Java动态代理只能够对接口进行代理，不能对普通的类进行代理（因为所有生成的代理类的父类为Proxy，Java类继承机制不允许多重继承）；CGLIB能够代理普通类；
  d. Spring内部，发现如果目标对象没有实现接口，则默认会采用CGLIB代理； 如果目标对象实现了接口，默认会采用Java动态代理；
  e. AOP用到的动态代理是对方法增强的方式之一。
  f. AOP的典型应用就是事务管理 。

代理
	#静态代理：编译时增强，修改目标对象的class文件
  #AspectJ：它会在编译阶段将Aspect织入Java字节码中， 运行的时候就是经过增强之后的AOP对象。
	#动态代理：运行时增强，生成代理对象
  #jdk动态代理：利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。
  	#被代理的对象必须要实现接口
  	#创建一个实现InvocationHandler的代理类
  	#使用Proxy.newProxyInstance(classLoader, interfaces, handler)产生代理对象
  #cglib动态代理：利用asm（一个短小精悍的字节码操作框架）开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。
  	#必须依赖于CGLib的类库
  	#可对无实现接口的类进行代理
  	#Enhancer类为主要类

82. tcp 为什么要三次握手，两次不行吗？为什么？

为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。
 如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。  

44. 创建线程池有哪几种方式？

①. newFixedThreadPool(int nThreads)

创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。

②. newCachedThreadPool()

创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。

③. newSingleThreadExecutor()

这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。

④. newScheduledThreadPool(int corePoolSize)
 创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。  
2.redis的持久化方式区别及其选择？（重要）
Redis 提供了 RDB 和 AOF 两种持久化方式：
RDB 是把内存中的数据集以快照形式写入磁盘，实际操作是通过 fork 子进程执行，采用二进制压缩存储；
AOF 是以文本日志的形式记录 Redis 处理的每一个写入或删除操作。
RDB 把整个 Redis 的数据保存在单一文件中，比较适合用来做灾备，但缺点是快照保存完成之前如果宕机，这段时间的数据将会丢失，另外保存快照时可能导致服务短时间不可用。
AOF 对日志文件的写入操作使用的追加模式，有灵活的同步策略，支持每秒同步、每次修改同步和不同步，缺点就是相同规模的数据集，AOF 要大于 RDB，AOF 在运行效率上往往会慢于 RDB。

redis的缓存击穿问题？如何解决？
1. 缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，缓存没读到数据，去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。
2. 关键字：缓存没有数据库有，并发多。
3. 和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。
4. 和缓存穿透不同的是，缓存穿透指缓存和数据库中都没有的数据。缓存击穿指的是缓存没有，数据库有
解决方案：
1. 设置热点数据永远不过期。
2. 加互斥锁(mutex key)。简单来讲，就是要操作db，需要排队。
redis的缓存穿透问题？如何解决？
缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求 
常见3种方案：
1. 增加接口层校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；
2. key-null存入缓存，从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。
这样可以防止攻击用户反复用同一个id暴力攻击
3. 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力
redis的缓存雪崩问题？怎么解决？
在高并发下，大量的缓存在同一时间失效，导致大量的请求落到数据库上
解决方案：
1. 设置不同的失效时间,比如随机设置缓存的失效时间。
2. 一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。
3. 设置热点数据永远不过期。
Redis的过期键的删除策略？
1. Redis中同时使用了惰性过期和定期过期两种过期策略。
2. 常见有3种过期策略，定期过期，定时过期，惰性过期。
3. 惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，
从而不会被清除，占用大量内存。
4. 定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。
5. 定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，
从而影响缓存的响应时间和吞吐量。
6. 定期、定时，是主动删除。惰性，是被动删除。
redis的使用场景？（
1. 缓存，将热点数据放到内存中。
2. 计数器，可以对 String 进行自增自减运算，从而实现计数器功能。
3. 队列，List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。
4. 分布式锁，在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。
5. 会话缓存，可以使用 Redis 来统一存储多台应用服务器的会话信息。
6. 全页缓存（FPC），除基本的会话token之外，Redis还提供很简便的FPC平台。没接触过。
7. 交集、差集、并集，Set 可以实现交集、差集、并集等操作，从而实现共同好友等功能。没接触过。
8. 排行榜，ZSet 可以实现有序性操作，从而实现排行榜等功能。没接触过。
9. 发布/订阅功能，用的少，没有MQ好。没接触过。



