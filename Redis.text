1. 使用redis有哪些好处？
(1) 读取速度快，因为：   1.数据存在内存中  2.采用单线程，避免了不必要的上下文切换    3.使用 I/O 复用模型
(2) 支持丰富数据类型，支持string，list(列表)，set，zset，hash，数据结构简单，Redis 中的数据结构是专门进行设计的。

(3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行。
   Redis 提供的不是严格的事务，Redis 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去。
(4) Redis 提供主从同步机制，以及 Cluster 集群部署能力，能够提供高可用服务。
2.redis的持久化方式区别及其选择？（重要）
Redis 提供了 RDB 和 AOF 两种持久化方式：
RDB 是把内存中的数据集以快照形式写入磁盘，实际操作是通过 fork 子进程执行，采用二进制压缩存储；
AOF 是以文本日志的形式记录 Redis 处理的每一个写入或删除操作。
RDB 把整个 Redis 的数据保存在单一文件中，比较适合用来做灾备，但缺点是快照保存完成之前如果宕机，这段时间的数据将会丢失，另外保存快照时可能导致服务短时间不可用。
AOF 对日志文件的写入操作使用的追加模式，有灵活的同步策略，支持每秒同步、每次修改同步和不同步，缺点就是相同规模的数据集，AOF 要大于 RDB，AOF 在运行效率上往往会慢于 RDB。

redis的缓存击穿问题？如何解决？
1. 缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，缓存没读到数据，去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。
2. 关键字：缓存没有数据库有，并发多。
3. 和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。
4. 和缓存穿透不同的是，缓存穿透指缓存和数据库中都没有的数据。缓存击穿指的是缓存没有，数据库有
解决方案：
1. 设置热点数据永远不过期。
2. 加互斥锁(mutex key)。简单来讲，就是要操作db，需要排队。
redis的缓存穿透问题？如何解决？
缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求 
常见3种方案：
1. 增加接口层校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；
2. key-null存入缓存，从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击
3. 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力
redis的缓存雪崩问题？怎么解决？
在高并发下，大量的缓存在同一时间失效，导致大量的请求落到数据库上
解决方案：
1. 设置不同的失效时间,比如随机设置缓存的失效时间。
2. 一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。
3. 设置热点数据永远不过期。
Redis的过期键的删除策略？
1. Redis中同时使用了惰性过期和定期过期两种过期策略。
2. 常见有3种过期策略，定期过期，定时过期，惰性过期。
3. 惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。
4. 定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。
5. 定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。
6. 定期、定时，是主动删除。惰性，是被动删除。
redis的使用场景？（
1. 缓存，将热点数据放到内存中。
2. 计数器，可以对 String 进行自增自减运算，从而实现计数器功能。
3. 队列，List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。
4. 分布式锁，在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。
5. 会话缓存，可以使用 Redis 来统一存储多台应用服务器的会话信息。
6. 全页缓存（FPC），除基本的会话token之外，Redis还提供很简便的FPC平台。没接触过。
7. 交集、差集、并集，Set 可以实现交集、差集、并集等操作，从而实现共同好友等功能。没接触过。
8. 排行榜，ZSet 可以实现有序性操作，从而实现排行榜等功能。没接触过。
9. 发布/订阅功能，用的少，没有MQ好。没接触过。

说一下redis的分布式锁怎么实现？
问题回答
1. Java中的锁，只能保证在同一个JVM进程内中执行。分布式集群需要分布式锁。
2. 分布式锁的实现有很多，比如基于数据库、memcached、Redis、系统文件、zookeeper等。
3. 针对单机Redis实例，也就是一个master
  a. 自己通过setnx获取锁，lua释放锁，或者通过set key value px milliseconds nx+lua（比setnx的方式更新）。
  b. 因为setnx没法设置过期时间，从 2.6.12 起，SET 涵盖了 SETEX 的功能，并且 SET 本身已经包含了设置过期时间的功能
  c. 或者通过封装好的redission框架。
4. 针对多个Redis实例，也就是N个Redis master
  a. 可以使用到RedLock（红锁）算法。
  b. 或者通过封装好的redission框架，redisson已经有对redlock算法封装。
5. RedLock原理（了解）
  a. 获取当前Unix时间，以毫秒为单位。
  b. 依次尝试从N个实例，使用相同的key和随机值获取锁。在步骤2，当向Redis设置锁时,客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例。
  c. 客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。当且仅当从大多数（这里是3个节点）的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。
  d. 如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。
  e. 如果因为某些原因，获取锁失败（没有在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功）。
参考redis在项目中哪些地方使用到了。
1. 垃圾图片的定时清理。
  a. 主要利用set结构
  b. 正确流程是，上传图片，保存套餐，如果只做了上传，没有提交套餐，那么这个图片其实是垃圾图片。
  c. 上传图片成功，图片地址存入一个set。
  d. 保存套餐成功，图片地址存入一个set。
  e. 通过set取差集，找到垃圾图片，然后清理。
2. 短信验证码5分钟过期
  a. 主要利用String结构
  b. 生成验证码，存入redis，设置5分钟过期。
  c. 收到验证码，从redis取出，看是否超过5分钟。
3. 购物车数据存入redis
  a. 使用了Hash结构
  b. 某个用户，某一个商品的购物车信息存入redis，key:用户名 ，field:sku的ID， value:购物车数据(order_item)
4. 秒杀
  a. 使用了List结构，做队列
  b. 用到了Hash结构
