




根据JVM规范，JVM 内存共分为虚拟机栈，堆，方法区，程序计数器，本地方法栈五个部分。
方法区和堆都是线程共享的，在JVM启动时创建，在JVM停止时销毁，而Java虚拟机栈、本地方法栈、程序计数器是线程私有的，随线程的创建而创建，随线程的结束而死亡。

堆内存可以细分为：
有人可能会问永久代到底是属于堆呢，还是属于方法区呢，其实在逻辑上永久代在逻辑上是和堆分开的，但物理上永久代是属于堆的。

虚拟机栈：
Java虚拟机栈是描述JAVA方法运行过程的内存模型，线程私有，每个方法执行都会创建一个栈帧，存储局部变量表、操作数栈、动态链接、方法返回地址(方法出口)等信息，
每个方法被调用至返回的过程【相当于清空了数据】, 就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程 (VM提供了-Xss来指定线程的最大栈空间, 该参数也直接决定了函数调用的最大深度)。
栈的生命周期与线程相同的，不需要进行GC。

局部变量表主要存放了编译器可知的各种数据类型(八种基本数据类型)、对象引⽤（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄）。


   栈中会发生的两种异常：StackOverFlowError和OutOfMemoryError：
● StackOverFlowError表示当前线程申请的栈超过了事先定好的栈的最大深度，但内存空间可能还有很多；
● OutOfMemoryError是指当线程申请栈时发现栈已经满了，而且内存也全都用光了。

本地方法栈(native方法)：
与虚拟机栈类似。本地方法栈是为虚拟机执行本地方法时提供服务的。不需要进行GC。

   本地方法栈结构上和Java虚拟机栈一样，只不过Java虚拟机栈是运行Java方法的区域，而本地方法栈是运行本地方法的内存模型。运行本地方法时也会创建栈帧，
   同样栈帧里也有局部变量表、操作数栈、动态链接和方法返回地址等，在本地方法执行结束后栈帧也会出栈并释放内存资源，也会发生OutOfMemoryError。

程序计数器：
线程私有的。内部保存的字节码的行号。不需要进行GC。

   程序计数器是一个比较小的内存空间，用来记录当前线程正在执行的那一条字节码指令的地址。如果当前线程正在执行的是本地方法，那么此时程序计数器为空。
   程序计数器有两个作用，1、字节码解释器通过改变程序计数器来一次读取指令，从而实现代码的流程控制，比如我们常见的顺序、循环、选择、异常处理等。
   2、在多线程的情况下，程序计数器用来记录当前线程执行的位置，当线程切换回来的时候仍然可以知道该线程上次执行到了哪里。而且程序计数器是唯一一个不会出现OutOfMeroryError的内存区域。

本地内存：
它又叫做堆外内存，线程共享的区域，本地内存这块区域是不会受到JVM的控制的，也就是说对于这块区域是不会发生GC的。因此对于整个java的执行效率是提升非常大的。

堆：
线程共享的区域。主要用来保存对象实例，数组（当然，数组引用是存放在Java栈中的）,字符串常量等，当堆中没有内存空间可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常。

在JAVA7中堆内会存在年轻代、老年代和方法区(永久代)。
1）Young区被划分为三部分，Eden区和两个大小严格相同的Survivor区，其中，Survivor区间中，某一时刻只有其中一个是被使用的，另外一个留做垃圾收集时复制对象用。
在Eden区变满的时候， GC就会将存活的对象移到空闲的Survivor区间（对象年龄增加一岁，每次GC，存活的对象都会在S0与S1之间移动，同时年龄加一）中，根据JVM的策略，
在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到Tenured区间。
2）Tenured区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在Young复制转移一定的次数（默认15岁）以后，对象就会被转移到Tenured区。
3）Perm代主要保存保存的类信息、静态变量、常量、编译后的代码, jdk1.7以后，字符串常量从永久代中剥离出来，存放在堆中。在java7中堆上方法区会受到GC的管理的。
方法区【永久代】是有一个大小的限制的。如果大量的动态生成类，就会放入到方法区【永久代】，很容易造成OOM (OutOfMerory)。
为了避免方法区出现OOM，所以在java8中将堆上的方法区【永久代】给移动到了本地内存上，重新开辟了一块空间，叫做元空间。那么现在就可以避免掉OOM的出现了。

堆内存分配原则：
  	#对象优先在Eden分配，当没有足够空间触发Minor GC
  	#大对象直接进入老年代，很长的字符串及数组都是大对象
  	#长期存活的对象进入老年代，新生代中经历一次Minor GC年龄就增加一岁，当达到默认的15岁，就进入老年代，这个默认值可以设置


运⾏时常量池
       运行时常量池是方法区的一部分。CLass文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息，用于存放编译期生成的各种字面量和符号引用，
       这部分内容将在类加载后进入方法区的运行时常量池中存放。
	运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，
  运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。
JDK1.7及之后版本的 JVM 已经将运⾏时常量池从⽅法区中移了出来，在 Java 堆（Heap）中开辟了⼀块区域存放运⾏时常量池。



● 使用元空间代替永久代的原因：
1. 字符串常量池存在永久代中，容易出现性能问题和内存溢出。
2. 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
3. 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。

类加载器
类的加载时机
1. 创建类的实例。
2. 类的静态变量，或者为静态变量赋值。
3. 类的静态方法。
4. 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象。
5. 初始化某个类的子类。
6. 直接使用java.exe命令来运行某个主类。
以上六种情况的任何一种，都可以导致JVM将一个类加载到方法区。
类加载器：是负责将磁盘上的某个class文件读取到内存并生成Class的对象。
Java中有三种类加载器，它们分别用于加载不同种类的class：
启动类加载器(Bootstrap ClassLoader)：用于加载系统类库<JAVA_HOME>\bin目录下的class，例如：rt.jar。
扩展类加载器(Extension ClassLoader)：用于加载扩展类库<JAVA_HOME>\lib\ext目录下的class。
应用程序类加载器(Application ClassLoader)：用于加载我们自定义类的加载器。

双亲委派模型：

上图展示了"类加载器"的层次关系，这种关系称为类加载器的"双亲委派模型"：
"双亲委派模型"中，除了顶层的启动类加载器外，其余的类加载器都应当有自己的"父级类加载器"。
这种关系不是通过"继承"实现的，通常是通过"组合"实现的。通过"组合"来表示父级类加载器。
"双亲委派模型"的工作过程：
某个"类加载器"收到类加载的请求，它首先不会尝试自己去加载这个类，而是把请求交给父级类加载器。
因此，所有的类加载的请求最终都会传送到顶层的"启动类加载器"中。
如果"父级类加载器"无法加载这个类，然后子级类加载器再去加载。



双亲委派机制描述：
    某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，一次递归，如果父类加载器可以完成加载任务，就成功返回；只有在父类加载器无法完成此加载任务时，才自己去加载。


1、保证安全性
        防止重复加载同一个.class。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。
2、保证唯一性
        保证核心.class不能被篡改。通过委托方式，不会去篡改核心.clas，即使篡改也不会去加载，即使加载也不会是同一个.class对象了。不同的加载器加载同一个.class也不是同一个Class对象。
        这样保证了Class执行安全。
试想，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，多个类加载器都去加载这个类到内存中，
系统中将会出现多个不同的Object类，那么类之间的比较结果及类的唯一性将无法保证，因为Object都各不相同那么程序运行启动就会出错，也保证了JVM能够正常的安全运行。
