线程安全：  https://www.cnblogs.com/hustzzl/p/9343797.html
当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些进程将如何交替执行，并且在主调代码中不需要任何额外的同步或协调，这个类都能表现出正确的行为，那么就称这个类时线程安全的。
线程安全主要体现在以下三个方面：
● 原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；
● 可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；
● 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。
指令重排序 是编译器和处理器为了优化程序执行的性能而对指令序列进行重排的一种手段。现象就是CPU 执行指令的顺序可能和程序代码的顺序不一致，例如 a = 1; b = 2; 可能 CPU 先执行b=2; 后执行a=1;

线程状态
线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。


线程的 run()和 start()有什么区别？
每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。
start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码；  这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态，  这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。
run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。

wait：释放占有的对象锁，释放CPU。
 sleep：则是释放CPU，但是不释放占有的对象锁。
notify：唤醒等待队列中的一个线程，使其获得锁进行访问。
notifyAll：唤醒等待队列中等待该对象锁的全部线程，让其竞争去获得锁。
 
  Lock：拥有synchronize相同的语义，但是添加一些其他特性，如中断锁等候和定时锁等候，所以可以使用lock代替synchronize。提供的方法有：
  lock()：以阻塞式获取锁，没有获取到一直等待，不会被中断。
  tryLock(): 获取一下，获取到就返回true，没获取到就返回false。
  tryLock(long timeout,TimeUnit unit):获取到返回true，没获取到等待给定的时间，还没获取到就返回false。
  lockInterruptibly() : 与lock类似，但是没有获取锁会进入到休眠状态，直到获得锁或者当前线程被别的线程中断。
 




JUC中的Atomic包详解：
Atomic包中提供了很多Atomicxxx的类：
Atomic 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。
所以，所谓原子类说简单点就是具有原子/原子操作特征的类。

AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。

什么是volatile关键字
volatile是一个"变量修饰符"，它只能修饰"成员变量"，它能并让其他线程的引用失效，强制线程每次从主内存获取值（不从缓存中获取值），并能保证此变量不会被编译器优化。
volatile能解决变量的可见性、有序性(禁止指令重排序)；
volatile不能解决变量的原子性。


 synchronized锁升级优化
java中每个对象都可作为锁，锁有四种级别，按照量级从轻到重分为：无锁，偏向锁，轻量级锁，重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级，

synchronized关键字最主要有以下3种应用方式，下面分别介绍
●     修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁
●     修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁
●     修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。

偏向锁：在不存在多线程竞争情况下，默认会开启偏向锁。
偏向锁升级轻量级锁：当一个对象持有偏向锁，一旦第二个线程访问这个对象，如果产生竞争，偏向锁升级为轻量级锁。
轻量级锁升级重量级锁：一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。

 说说 synchronized 关键字和 volatile 关键字的区别
synchronized 关键字和 volatile 关键字是两个互补的存在，而不是对立的存在！
● volatile 关键字是线程同步的轻量级实现，所以volatile 性能肯定比 synchronized 关键字要好。但是volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块。
● volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。
● volatile 关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。

Lock锁
Lock用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就是CAS操作（Compare and Swap）。我们可以进一步研究ReentrantLock的源代码，会发现其中比较重要的获得锁的一个方法是compareAndSetState。这里其实就是调用的CPU提供的特殊指令。

ReentrantLock与synchronized的比较:
● 性能不一致：资源竞争激励的情况下，lock性能会比synchronize好，竞争不激励的情况下，synchronize比lock性能好。
●  锁机制不一样：synchronize是在JVM层面实现的，系统会监控锁的释放与否。lock是代码实现的，需要手动释放，在finally块中释 放。可以采用非阻塞的方式获取锁。
●   用法不一样：synchronize可以用在代码块上，方法上。lock通过代码实现，有更精确的线程语义。

读写锁特性:ReadWriteLock定义了两个方法。readLock()返回用于读操作的锁，writeLock()返回用于写操作的锁。
1. 读操作不互斥，写操作互斥，读和写互斥。
2. 公平性：支持公平性和非公平性。
3. 重入性：支持锁重入。
4. 锁降级：写锁能够降级成为读锁，遵循获取写锁、获取读锁在释放写锁的次序。读锁不能升级为写锁。

乐观锁常见的两种实现方式
乐观锁一般会使用版本号机制或CAS算法实现。

1. 版本号机制
      一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。
2. CAS算法
即compare and swap（比较与交换），是一种有名的无锁算法，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。
CAS算法涉及到三个操作数
● 需要读写的内存值 V
● 进行比较的值 A
● 拟写入的新值 B
当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作。一般情况下是一个自旋操作，即不断的重试。

死锁
1.造成死锁的原因:
1. 当前线程拥有其他线程需要的资源
2. 当前线程等待其他线程已拥有的资源
3. 都不放弃自己拥有的资源

2.死锁排查:
1. 通过JDK工具jps+jstack
2. 通过JDK工具jconsole
3. 通过JDK工具VisualVM

3.避免死锁的常见方法;
1）避免一个线程同时获取多个锁。
2）避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。
3）尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制。线程安全：
当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些进程将如何交替执行，并且在主调代码中不需要任何额外的同步或协调，这个类都能表现出正确的行为，那么就称这个类时线程安全的。
线程安全主要体现在以下三个方面：
● 原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；
● 可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；
● 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。
指令重排序 是编译器和处理器为了优化程序执行的性能而对指令序列进行重排的一种手段。现象就是CPU 执行指令的顺序可能和程序代码的顺序不一致，例如 a = 1; b = 2; 可能 CPU 先执行b=2; 后执行a=1;

线程状态
线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。


线程的 run()和 start()有什么区别？
每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。
start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码；  这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态，  这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。
run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。

wait：释放占有的对象锁，释放CPU。
 sleep：则是释放CPU，但是不释放占有的对象锁。
notify：唤醒等待队列中的一个线程，使其获得锁进行访问。
notifyAll：唤醒等待队列中等待该对象锁的全部线程，让其竞争去获得锁。
 
  Lock：拥有synchronize相同的语义，但是添加一些其他特性，如中断锁等候和定时锁等候，所以可以使用lock代替synchronize。提供的方法有：
  lock()：以阻塞式获取锁，没有获取到一直等待，不会被中断。
  tryLock(): 获取一下，获取到就返回true，没获取到就返回false。
  tryLock(long timeout,TimeUnit unit):获取到返回true，没获取到等待给定的时间，还没获取到就返回false。
  lockInterruptibly() : 与lock类似，但是没有获取锁会进入到休眠状态，直到获得锁或者当前线程被别的线程中断。
 




JUC中的Atomic包详解：
Atomic包中提供了很多Atomicxxx的类：
Atomic 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。
所以，所谓原子类说简单点就是具有原子/原子操作特征的类。

AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。

什么是volatile关键字
volatile是一个"变量修饰符"，它只能修饰"成员变量"，它能并让其他线程的引用失效，强制线程每次从主内存获取值（不从缓存中获取值），并能保证此变量不会被编译器优化。
volatile能解决变量的可见性、有序性(禁止指令重排序)；
volatile不能解决变量的原子性。


 synchronized锁升级优化
java中每个对象都可作为锁，锁有四种级别，按照量级从轻到重分为：无锁，偏向锁，轻量级锁，重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级，

synchronized关键字最主要有以下3种应用方式，下面分别介绍
●     修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁
●     修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁
●     修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。

偏向锁：在不存在多线程竞争情况下，默认会开启偏向锁。
偏向锁升级轻量级锁：当一个对象持有偏向锁，一旦第二个线程访问这个对象，如果产生竞争，偏向锁升级为轻量级锁。
轻量级锁升级重量级锁：一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。

 说说 synchronized 关键字和 volatile 关键字的区别
synchronized 关键字和 volatile 关键字是两个互补的存在，而不是对立的存在！
● volatile 关键字是线程同步的轻量级实现，所以volatile 性能肯定比 synchronized 关键字要好。但是volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块。
● volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。
● volatile 关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。

Lock锁
Lock用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就是CAS操作（Compare and Swap）。我们可以进一步研究ReentrantLock的源代码，会发现其中比较重要的获得锁的一个方法是compareAndSetState。这里其实就是调用的CPU提供的特殊指令。

ReentrantLock与synchronized的比较:
● 性能不一致：资源竞争激励的情况下，lock性能会比synchronize好，竞争不激励的情况下，synchronize比lock性能好。
●  锁机制不一样：synchronize是在JVM层面实现的，系统会监控锁的释放与否。lock是代码实现的，需要手动释放，在finally块中释 放。可以采用非阻塞的方式获取锁。
●   用法不一样：synchronize可以用在代码块上，方法上。lock通过代码实现，有更精确的线程语义。

读写锁特性:ReadWriteLock定义了两个方法。readLock()返回用于读操作的锁，writeLock()返回用于写操作的锁。
1. 读操作不互斥，写操作互斥，读和写互斥。
2. 公平性：支持公平性和非公平性。
3. 重入性：支持锁重入。
4. 锁降级：写锁能够降级成为读锁，遵循获取写锁、获取读锁在释放写锁的次序。读锁不能升级为写锁。

乐观锁常见的两种实现方式
乐观锁一般会使用版本号机制或CAS算法实现。

1. 版本号机制
      一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。
2. CAS算法
即compare and swap（比较与交换），是一种有名的无锁算法，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。
CAS算法涉及到三个操作数
● 需要读写的内存值 V
● 进行比较的值 A
● 拟写入的新值 B
当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作。一般情况下是一个自旋操作，即不断的重试。

死锁
1.造成死锁的原因:
1. 当前线程拥有其他线程需要的资源
2. 当前线程等待其他线程已拥有的资源
3. 都不放弃自己拥有的资源

2.死锁排查:
1. 通过JDK工具jps+jstack
2. 通过JDK工具jconsole
3. 通过JDK工具VisualVM

3.避免死锁的常见方法;
1）避免一个线程同时获取多个锁。
2）避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。
3）尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制。
