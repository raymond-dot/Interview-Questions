1 分布式锁介绍  https://blog.csdn.net/weixin_46919654/article/details/126605738
1.1 什么是分布式
一个大型的系统往往被分为几个子系统来做，一个子系统可以部署在一台机器的多个 JVM(java虚拟机) 上，也可以部署在多台机器上。但是每一个系统不是独立的，不是完全独立的。需要相互通信，共同实现业务功能。
一句话来说：分布式就是通过计算机网络将后端工作分布到多台主机上，多个主机一起协同完成工作。
1.2 什么是锁
现实生活中，当我们需要保护一样东西的时候，就会使用锁。例如门锁，车锁等等。很多时候可能许多人会共用这些资源，就会有很多个钥匙。但是有些时候我们希望使用的时候是独自不受打扰的，那么就会在使用的时候从里面反锁，等使用完了再从里面解锁。这样其他人就可以继续使用了。
JAVA程序中，当存在多个线程可以同时改变某个变量（可变共享变量）时，就需要对变量或代码块做同步，使其在修改这种变量时能够线性执行消除并发修改变量，而同步的本质是通过锁来实现的。如 Java 中 synchronize 是在对象头设置标记。
1.3 什么是分布式锁
任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。
分布式锁: 在分布式环境下，多个程序/线程都需要对某一份(或有限制)的数据进行修改时，针对程序进行控制，保证同一时间节点下，只有一个程序/线程对数据进行操作的技术。
1.4 分布式锁的执行流程


1.5 分布式锁具备的条件
互斥性：同一时刻只能有一个服务(或应用)访问资源。
原子性：一致性要求保证加锁和解锁的行为是原子性的。
安全性：锁只能被持有该锁的服务(或应用)释放。
容错性：在持有锁的服务崩溃时，锁仍能得到释放，避免死锁。
高可用：获取锁和释放锁 要高可用。
高性能：获取锁和释放锁的性能要好。
持久性：锁按业务需要自动续约/自动延期。

2.分布式锁的解决方案
那么我所了解到现在分布式锁有三种实现方案。
1.基于数据库。
2.基于缓存环境，redis，memcache等。
3.基于zookeeper。
方案的实现注意点
1.首先保证在分布式的环境中，同一个方法只能被同一个服务器上的一个线程执行。
2.锁要可重入，严重一点的场景不能获取锁之后如果需要再次获取时发现不能获取了，造成死锁。
3.锁要可阻塞。这一般只要保证有个超时时间就行。
4.高可用的加锁和释放锁功能。
5.加锁和释放锁的性能要好。

2.3 Redis实现分布式锁
2.3.1 单节点Redis实现分布式锁
2.3.1.1 原理&实现
分布式锁的一个很重要的特性就是互斥性，同一时间内多个调用方加锁竞争，只能有一个调用方加锁成功。而
redis是基于单线程模型的，可以利用这个特性让调用方的请求排队，对于并发请求，只会有一个请求能获取到
锁。
redis实现分布式锁也很简单，基于客户端的几个API就可以完成，主要涉及三个核心API：
setNx()：向redis中存key-value，只有当key不存在时才会设置成功，否则返回0。用于体现互斥性。
expire()：设置key的过期时间，用于避免死锁出现。
delete()：删除key，用于释放锁

说一下redis的分布式锁怎么实现？
问题回答
1. Java中的锁，只能保证在同一个JVM进程内中执行。分布式集群需要分布式锁。
2. 分布式锁的实现有很多，比如基于数据库、memcached、Redis、系统文件、zookeeper等。
3. 针对单机Redis实例，也就是一个master
  a. 自己通过setnx获取锁，lua释放锁，或者通过set key value px milliseconds nx+lua（比setnx的方式更新）。
  b. 因为setnx没法设置过期时间，从 2.6.12 起，SET 涵盖了 SETEX 的功能，并且 SET 本身已经包含了设置过期时间的功能
  c. 或者通过封装好的redission框架。
4. 针对多个Redis实例，也就是N个Redis master
  a. 可以使用到RedLock（红锁）算法。
  b. 或者通过封装好的redission框架，redisson已经有对redlock算法封装。
5. RedLock原理（了解）
  a. 获取当前Unix时间，以毫秒为单位。
  b. 依次尝试从N个实例，使用相同的key和随机值获取锁。在步骤2，当向Redis设置锁时,客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例。
  c. 客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。当且仅当从大多数（这里是3个节点）的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。
  d. 如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。
  e. 如果因为某些原因，获取锁失败（没有在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功）。
  /**
    * 分布式锁在项目中使用案例，对支付流程进行限制，防止订单重复支付
    */
	@Override
    public String rlock(String orderId) {
        //初始化锁的对象
        RLock rLock = redissonClient.getLock("lock_" + orderId);
        try {
            //尝试加锁, 最多等待5秒
            boolean lock = rLock.tryLock(5, -1, TimeUnit.SECONDS);
            if (lock) {
                log.debug("获取到锁，执行支付流程");
                //延时15s
                Thread.sleep(15000);
                log.debug("支付完成");
                return "支付完成";
            } else {
                return "请稍等，有人正在支付";
            }
        } catch (InterruptedException e) {
            log.error("获取锁异常 e:{}", e.getMessage());
            return "获取锁异常";
        } finally {
            //是锁定状态，并且是当前执行线程的锁，释放锁
            if (rLock.isLocked() && rLock.isHeldByCurrentThread()) {
                rLock.unlock();
            }
        }
    }
